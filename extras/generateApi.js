// Generates the SiC45x.h and SiC45x.cpp files from the pmbusConfig object.

const fs = require('node:fs');

const main = (pmbusConfig) => {
  const headerContent = generateHeader(pmbusConfig);
  fs.writeFile(`${pmbusConfig.name}.h`, headerContent, console.error);

  const implContent = generateImpl(pmbusConfig);
  fs.writeFile(`${pmbusConfig.name}.cpp`, implContent, console.error);
};

const generateHeader = (pmbusConfig) => {

  let content = `
// This file was generated by the generateApi.js, do not edit it manually.
// Change the pmbusConfig in generateApi.js and call node generateApi.js to
// regenerate this file.

#ifndef SIC45X_H_
#define SIC45X_H_

#include <Wire.h>
#include <stdint.h>

#include "smbus.h"

${generateSymbols(pmbusConfig)}

${generateClassHeader(pmbusConfig)}

#endif
  `.trim();

  return content;
};

const generateSymbols = (pmbusConfig) => {
  const symbols = [];
  symbols.push(pmbusConfig.commands.map((command) => generateCommandSymbol(pmbusConfig.name, command)).filter(e => e).join('\n'));
  if (pmbusConfig.customMacros) {
    symbols.push(pmbusConfig.customMacros);
  }
  return symbols.join('\n');
};

const generateCommandSymbol = (icName, command) => {
  if (command.visible === false) {
    return '';
  }
  const symbols = [];
  symbols.push(`#define ${toCommandSymbol(icName, command.name)} ${toHex(command.address, 2)}`);
  if (command.exponent !== undefined) {
    symbols.push(`#define ${toExponentSymbol(icName, command.name)} ${command.exponent}`);
  }
  symbols.push(generateParserSymbols(icName, command))

  return symbols.join('\n').trim();
};

const generateParserSymbols = (icName, command) => {
  if (command.parser === undefined || command.parser.length === 0) {
    return '';
  }
  const ic = toMacro(icName);
  const commandName = toMacro(command.name);
  const symbols = [];
  for (const parser of command.parser) {
    if (parser.visible === false) {
      continue;
    }
    const parserEntryName = toMacro(parser.name);
    for (const value of parser.values) {
      const valueName = toMacro(value.name);
      const valueHex = toHex(value.value, parser.len);
      if (value.des) {
        symbols.push(generateComment(value.des, 0));
      }
      symbols.push(`#define ${ic}_${commandName}_${parserEntryName}_${valueName} ${valueHex} << ${parser.pos}`);
    }
  }
  return symbols.join('\n');
}

const generateClassHeader = (pmbusConfig) => {
  const prettyPrintHelpers = pmbusConfig.prettyPrint ? `\n\n${indentByLevel(generatePrettyPrintHelpers(), 1)}` : '';
  return `
class ${pmbusConfig.name} {
  Smbus smbus_;
  float l16ToFloat(uint16_t inputVal);
  uint16_t floatToL16(float inputVal);

 public:
  ${pmbusConfig.name}(uint8_t i2cAddress);
  ${pmbusConfig.name}(uint8_t i2cAddress, TwoWire& wire);
  bool begin();

${indentByLevel(generateCommandMethods(pmbusConfig.commands, pmbusConfig.prettyPrint), 1)}${prettyPrintHelpers}
};
`.trim();
};

const generateCommandMethods = (commands, prettyPrint) => {
  return commands.map((command) => generateCommandMethod(command, prettyPrint)).filter(e => e).join('\n');
}

const generateCommandMethod = (command, prettyPrint) => {
  if (command.visible === false) {
    return '';
  }
  if (command.rw !== 'r' && command.rw !== 'w' && command.rw !== 'rw') { 
    throw new Error(`Invalid rw value ${command.rw} for command ${command.name}`);
  }
  const isRead = command.rw.indexOf('r') >= 0;
  const isWrite = command.rw.indexOf('w') >= 0;
  const isStatus = command.parser;
  const isCommand = command.type === 'command';

  const methodNameBase = toMethod(command.name);
  const commandMethods = [];

  if (command.des) {
    commandMethods.push(generateComment(command.des, 0));
  }
  if (isCommand) {
    commandMethods.push(`void send${methodNameBase}();`);
  } else {
    const type = findType(command);
    const statusType = toType(command.name);
  
    if (isRead) {
      commandMethods.push(`${type} get${methodNameBase}();`);
      if (isStatus && prettyPrint) {
        commandMethods.push(`void print${methodNameBase}();`);
      }
    }
    if (isWrite) {
      commandMethods.push(`void set${methodNameBase}(${type} value);`);
    }
  }

  return commandMethods.join('\n');
}

const findType = (command) => {
  switch (command.type) {
    case 'byte':
      return 'uint8_t';
    case 'word':
      return 'uint16_t';
    case 'l16':
      return 'float';
    case 'l11':
      return 'float';
    default:
      throw new Error(`Invalid type ${command.type} for command ${command.name}`);
  }
}

const generateImpl = (pmbusConfig) => {
  return `
// This file was generated by the generateApi.js, do not edit it manually.
// Change the pmbusConfig in generateApi.js and call node generateApi.js to
// regenerate this file.

#include <Arduino.h>
  
#include "SiC45x.h"

SiC45x::SiC45x(uint8_t i2cAddress) : SiC45x(i2cAddress, Wire) {}

SiC45x::SiC45x(uint8_t i2cAddress, TwoWire& wire) : smbus_(i2cAddress, wire) {}

bool SiC45x::begin() { return smbus_.begin(); }

${generateCommandImpl(pmbusConfig)}

${generateL16Methods(pmbusConfig)}
  `.trim();
};

const generateCommandImpl = (pmbusConfig) => {
  return pmbusConfig.commands
      .filter(command => command.visible !== false)
      .map((command) => generateCommandImplMethod(pmbusConfig.name, command, pmbusConfig.prettyPrint))
      .filter(e => e)
      .join('\n\n');
};

const generateCommandImplMethod = (icName, command, prettyPrint) => {
  const isRead = command.rw.indexOf('r') >= 0;
  const isWrite = command.rw.indexOf('w') >= 0;
  const isStatus = command.parser;
  const isCommand = command.type === 'command';

  const commandMethods = [];
  if (isCommand) {
    commandMethods.push(generateCommandImplCommandMethod(command, icName));
  } else {
    if (isRead) {
      commandMethods.push(generateCommandImplReadMethod(command, icName, false));
      if (isStatus && prettyPrint) {
        commandMethods.push(generateCommandImplPrettyPrintMethod(command, icName));
      }
    }
    if (isWrite) {
      commandMethods.push(generateCommandImplWriteMethod(command, icName, false));
    }
  }

  return commandMethods.join('\n\n');
};

const generateCommandImplCommandMethod = (command, icName) => {
  const commandSymbol = toCommandSymbol(icName, command.name);
  return `void ${icName}::send${toMethod(command.name)}() { smbus_.sendByte(${commandSymbol}); }`;
};

const generateCommandImplReadMethod = (command, icName, raw) => {
  const type = findType(command);
  const methodNameBase = toMethod(command.name);
  const commandSymbol = toCommandSymbol(icName, command.name);
  const method = [];
  method.push(`${type} ${icName}::get${methodNameBase}${raw ? 'Raw' : ''}() {`);
  if (command.type === 'l16') {
    method.push(`  return l16ToFloat(smbus_.readWord(${commandSymbol}));`);
  } else if (command.type === 'l11') {
    method.push(`  return smbus_.l11ToFloat(smbus_.readWord(${commandSymbol}));`);
  } else {
    const smbMethod = command.type === 'byte' ? 'readByte' : 'readWord';
    method.push(`  return smbus_.${smbMethod}(${commandSymbol});`);
  }
  method.push('}');
  return method.join('\n');
}

const generateCommandImplPrettyPrintMethod = (command, icName) => {
  const type = findType(command);
  const stateType = toType(command.name);
  const commandName = toMacro(command.name);
  const ic = toMacro(icName);
  const method = [];
  method.push(`void ${icName}::print${stateType}() {`);
  method.push(`  ${type} value = get${stateType}();`);
  method.push(`  Serial.println(F("${stateType}: "));`);
  for (const parser of command.parser) {
    if (parser.visible === false) {
      continue;
    }
    const enumType = `${toType(command.name)}${toType(parser.name)}`;
    const parserEntryName = toMacro(parser.name);
    const mask = `0b${'1'.repeat(parser.len)} << ${parser.pos}`;
    method.push(`  Serial.print(F("  ${toType(parser.name)}: "));`);
    for (const value of parser.values) {
      const valueName = toMacro(value.name);
      method.push(`  printIfEq(value, ${mask}, ${ic}_${commandName}_${parserEntryName}_${valueName}, F("${valueName}"));`);
    }
    method.push(`  Serial.println();`);
  }
  method.push('}');
  return method.join('\n');
}

const generateCommandImplWriteMethod = (command, icName, raw) => {
  const type = findType(command);
  const methodNameBase = toMethod(command.name);
  const commandSymbol = toCommandSymbol(icName, command.name);
  const method = [];
  method.push(`void ${icName}::set${methodNameBase}${raw ? 'Raw' : ''}(${type} value) {`);
  if (command.type === 'l16') {
    method.push(`  smbus_.writeWord(${commandSymbol}, floatToL16(value));`);
  } else if (command.type === 'l11') {
    if (command.exponent === undefined) {
      method.push(`  smbus_.writeWord(${commandSymbol}, smbus_.floatToL11(value));`);
    } else {
      method.push(`  smbus_.writeWord(${commandSymbol}, smbus_.floatToL11(value, ${toExponentSymbol(icName, command.name)}));`);
    }
  } else {
    const smbMethod = command.type === 'byte' ? 'writeByte' : 'writeWord';
    method.push(`  smbus_.${smbMethod}(${commandSymbol}, value);`);
  }
  method.push('}');
  return method.join('\n');
}

const generatePrettyPrintHelpers = () => {
  return `
inline void printIfEq(uint16_t value, uint16_t mask, uint16_t flag, const __FlashStringHelper *str) {
  if ((value & mask) == flag) {
    Serial.print(str);
  }
}
  `.trim();  
}

const toHex = (num, len) => toBase(num, len, 16, '0x');
const toBin = (num, len) => toBase(num, len, 2, '0b');

const toBase = (num, len, base, prefix) => {
  let numFormatted = num.toString(base);
  if (len !== undefined) {
    numFormatted = numFormatted.padStart(len, '0');
  }
  return `${prefix}${numFormatted}`;
};

// generates a string representing a commnet of 80 caracters using `//` only
const generateComment = (comment, level, assumedLevel) => {
  if (!comment) {
    return '';
  }
  assumedLevel = assumedLevel || 0;
  const prefix = ' '.repeat(level * 2) + '// ';
  const prefixLength = prefix.length;
  const commentLength = 80 - prefixLength - assumedLevel * 2;
  // split comment in lines of full words no longer than commentLength
  const words = comment.split(' ');
  const lines = [];
  let line = '';
  for (const word of words) {
    if (line.length + word.length + 1 > commentLength) {
      lines.push(line);
      line = word;
    } else {
      if (line.length > 0) {
        line += ' ';
      }
      line += word;
    }
  }
  lines.push(line);
  return lines.map((line) => prefix + line).join('\n');
}

const generateL16Methods = (pmbusConfig) => {
  const voutModeCommand = pmbusConfig.commands.find((command) => command.name === 'VOUT_MODE');
  if (!voutModeCommand) {
    throw new Error('VOUT_MODE command not found');
  }
  const behavior = voutModeCommand.behavior;
  if (behavior !== 'constant') {
    throw new Error(`Unsupported VOUT_MODE behavior ${behavior}`);
  }
  return `
float SiC45x::l16ToFloat(uint16_t inputVal) {
  return smbus_.l16ToFloat(${toHex(voutModeCommand.default, 2)}, inputVal);
}

uint16_t SiC45x::floatToL16(float inputVal) {
  return smbus_.floatToL16(${toHex(voutModeCommand.default, 2)}, inputVal);
}
`.trim();
}

const toMacro = (name) => name.split(/[^A-Za-z0-9]/).map((word) => word.toUpperCase()).join('_');
const toCommandSymbol = (icName, commandName) => `${toMacro(icName)}_${toMacro(commandName)}_CMD`;
const toExponentSymbol = (icName, commandName) => `${toMacro(icName)}_${toMacro(commandName)}_EXP`;
const toMethod = (name) => name.split(/[^A-Za-z0-9]/).map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');
const toType = (name) => name.split(/[^A-Za-z0-9]/).map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');

const indentByLevel = (lines, level) => {
  return lines.split('\n').map((line) => line ? ' '.repeat(level * 2) + line : '').join('\n');
};

// from https://www.vishay.com/docs/77863/sic450_sic451_sic453.pdf
const pmbusConfig = {
  name: "SiC45x",
  prettyPrint: true,
  commands: [
    {
      address: 0x01,
      name: "OPERATION",
      des: "The OPERATION command sets the operational state of the regulator.",
      type: "byte",
      rw: "rw",
      default: 0x88,
      parser: [
        {
          name: "On/off",
          pos: 7,
          len: 1,
          values: [
            {value: 0b0, name: "disabled", des: "Output is disabled"},
            {value: 0b1, name: "enabled", des: "Output is enabled"},
          ],
        },
        {
          name: "Off B",
          pos: 6,
          len: 1,
          values: [
            {value: 0b0, name: "immediate", des: "Output is turned off immediately and power off sequence commands ignored"},
            {value: 0b1, name: "delayed", des: "Regulator turns off following the TOFF_DELAY and TOFF_FALL command"},
          ],
        },
        {
          name: "Margin",
          pos: 4,
          len: 2,
          values: [
            {value: 0b00, name: "command", des: "Output voltage is set by the PMBus VOUT_COMMAND data"},
            {value: 0b01, name: "low", des: "Output voltage is set by the PMBus VOUT_MARGIN_LOW data"},
            {value: 0b10, name: "high", des: "Output voltage is set by the PMBus VOUT_MARGIN_HIGH data"},
            {value: 0b11, name: "not supported", des: "Not supported", supported: false},
          ],
        },
        {
          name: "MRGNFLT",
          pos: 2,
          len: 2,
          values: [
            {value: 0b00, name: "not supported 1", des: "Not supported", supported: false},
            {value: 0b01, name: "ignore", des: "Faults caused by selecting VOUT_MARGIN_HIGH or VOUT_MARGIN_LOW as the nominal output voltage source are ignored"},
            {value: 0b10, name: "follow", des: "Faults caused by selecting VOUT_MARGIN_HIGH or VOUT_MARGIN_LOW as the nominal output voltage source are acted upon according to the settings of the VOUT_OV_FAULT_RESPONSE and VOUT_UV_FAULT_RESPONSE"},
            {value: 0b11, name: "not supported 2", des: "Not supported", supported: false},
          ],
        },
      ],
    },
    {
      address: 0x02,
      name: "ON_OFF_CONFIGURATION",
      des: "The ON_OFF_CONFIG command configures the combination of EN pin input and PMBus commands needed to turn the unit on and off. This includes how the unit responds when power is applied.",
      type: "byte",
      rw: "rw",
      default: 0x1F,
      parser: [
        {
          name: "RSV",
          pos: 5,
          len: 3,
          visible: false,
        },
        {
          name: "PU",
          pos: 4,
          len: 1,
          values: [
            {value: 0b0, name: "power", des: "Regulator powers up any time power is present regardless of state of the EN pin"},
            {value: 0b1, name: "command", des: "Regulator does not power up until commanded by the CONTROLEN pin and OPERATION command"},
          ],
        },
        {
          name: "CMD",
          pos: 3,
          len: 1,
          values: [
            {value: 0b0, name: "ignore", des: "Regulator ignores the \"on\" bit in the OPERATION command"},
            {value: 0b1, name: "respond", des: "Regulator responds the \"on\" bit in the OPERATION command"},
          ],
        },
        {
          name: "EN",
          pos: 2,
          len: 1,
          values: [
            {value: 0b0, name: "ignore", des: "Regulator ignores the EN pin. Power conversion is controlled only by the OPERATION command"},
            {value: 0b1, name: "require", des: "Regulator requires the EN pin to be asserted to start the unit"},
          ],
        },
        {
          name: "ENPOL",
          pos: 1,
          len: 1,
          values: [
            {value: 0b0, name: "low", des: "EN signal is active low"},
            {value: 0b1, name: "high", des: "EN signal is active high"},
          ],
        },
        {
          name: "OFFB1",
          pos: 0,
          len: 1,
          values: [
            {value: 0b0, name: "delayed", des: "Regulator turns off following the t OFF_DELAY and t OFF_FALL command when EN signal is used to turn off"},
            {value: 0b1, name: "immediate", des: "Regulator turns off immediately"},
          ],
        },
      ],
    },
    {
      address: 0x03,
      name: "CLEAR_FAULTS",
      des: "The CLEAR_FAULTS command is used to clear any fault bits that have been set",
      type: "command",
      rw: "w",
    },
    {
      address: 0x10,
      name: "WRITE_PROTECT",
      des: "The WRITE_PROTECT command is used to control writing to the PMBus device",
      type: "byte",
      rw: "w",
      default: 0x00,
      parser: [
        {
          name: "WTPRT",
          pos: 5,
          len: 3,
          values: [
            {value: 0b000, name: "all", des: "Enable writes to all commands"},
            {value: 0b100, name: "protected", des: "Disable all writes except to the WRITE_PROTECT command"},
            {value: 0b010, name: "operation command", des: "Disable all writes except to the WRITE_PROTECT and OPERATION commands"},
            {value: 0b001, name: "on off vout", des: "Disable all writes except to the WRITE_PROTECT, OPERATION, ON_OFF_CONFIG and VOUT_COMMAND commands"},
          ],
        },
      ],
    },
    {
      address: 0x15,
      name: "STORE_USER_ALL",
      des: "The STORE_USER_ALL command instructs the PMBus device to copy the entire contents of the operating memory to the matching locations in the non-volatile User Store memory.",
      type: "command",
      rw: "w",
    },
    {
      address: 0x16,
      name: "RESTORE_USER_ALL",
      des: "The RESTORE_USER_ALL command instructs the PMBus device to copy the entire contents of the nonvolatile user store memory (NVM) to the matching locations in the operating memory.",
      type: "command",
      rw: "w",
    },
    {
      address: 0x19,
      name: "CAPABILITY",
      des: "The CAPABILITY command provides a way for a host system to determine some key capabilities of the PMBus device.",
      type: "byte",
      rw: "r",
      default: 0xD0,
      parser: [
        {
          name: "PEC",
          pos: 7,
          len: 1,
          values: [
            {value: 0b1, name: "supported", des: "Packet error checking is supported"},
          ],
        },
        {
          name: "SPD",
          pos: 5,
          len: 2,
          values: [
            {value: 0b10, name: "M1", des: "Maximum supported bus speed is 1 MHz"},
          ],
        },
        {
          name: "ALRT",
          pos: 4,
          len: 1,
          values: [
            {value: 0b1, name: "supported", des: "The unit has ALERT# pin and supports PMBus alert response protocol"},
          ],
        },
        {
          name: "NFMT",
          pos: 3,
          len: 1,
          values: [
            {value: 0b1, name: "l11 l16 direct", des: "Numeric data is in LINEAR11, LINEAR16, or DIRECT format"},
          ],
        },
        {
          name: "AVS",
          pos: 3,
          len: 1,
          values: [
            {value: 0b1, name: "not supported", des: "AVSBUS not supported"},
          ],
        },
        {
          name: "RSV",
          pos: 0,
          len: 2,
          visible: false,
        },
      ],
    },
    {
      address: 0x1B,
      name: "SMBALERT_MASK",
      des: "",
      type: "block",
      rw: "rw",
      default: 0x0000,
      visible: false,
    },
    {
      address: 0x20,
      name: "VOUT_MODE",
      des: "The PMBus specification dictates that the data word for the V OUT_MODE command is one byte that consists of a 3-bit mode and 5-bit exponent parameter, as shown below. The 3-bit mode sets whether the device uses the linear or direct modes for output voltage related commands. The 5-bit parameter sets the exponent value for the linear data mode. The mode and exponent parameters are fixed and do not permit the user to change the values.",
      type: "l16",
      rw: "r",
      default: 0x17,
      behavior: "constant",
    },
    {
      address: 0x21,
      name: "VOUT_COMMAND",
      des: "The VOUT_COMMAND is used to directly set the output voltage",
      type: "l16",
      rw: "rw",
      default: 0x0133,
    },
    {
      address: 0x22,
      name: "VOUT_TRIM",
      des: "The VOUT_TRIM command is used to apply a fixed offset voltage to the output voltage command value",
      type: "l16",
      rw: "rw",
      visible: false,
    },
    {
      address: 0x24,
      name: "VOUT_MAX",
      des: "The VOUT_MAX command sets an upper limit on the output voltage the unit can command regardless of any other commands or combinations",
      type: "l16",
      rw: "rw",
      default: 0x1C00,
    },
    {
      address: 0x25,
      name: "VOUT_MARGIN_HIGH",
      des: "The VOUT_MARGIN_HIGH command loads the unit with the voltage to which the output is to be changed when the OPERATION command is set to \"margin high\"",
      type: "l16",
      rw: "rw",
      default: 0x0142,
    },
    {
      address: 0x26,
      name: "VOUT_MARGIN_LOW",
      des: "The VOUT_MARGIN_LOW command loads the unit with the voltage to which the output is to be changed when the OPERATION command is set to margin low",
      type: "l16",
      rw: "rw",
      default: 0x0123,
    },
    {
      address: 0x27,
      name: "VOUT_TRANSITION_RATE",
      des: "The VOUT_TRANSITION_RATE command sets the rate in mV/μs at which the output voltage should change voltage when a PMBus device receives either a VOUT_COMMAND or OPERATION (margin high, margin low) that causes the output voltage to change",
      type: "l11",
      exponent: -4,
      rw: "rw",
      default: 0xE002,
    },
    {
      address: 0x29,
      name: "VOUT_SCALE_LOOP",
      des: "The VOUT_SCALE_LOOP command is used to scale down both the VOUT_COMMAND and the sense differential output voltage at the unit input, so as to extend operational range of the PMBus unit to reach the maximum output voltage 12 V without the requirement of external resistor divider on board",
      type: "l11",
      exponent: -3,
      rw: "rw",
      default: 0xE808,
    },
    {
      address: 0x33,
      name: "FREQUENCY_SWITCH",
      des: "The FREQUENCY_SWITCH command sets the switching frequency, in kHz, of the PMBus unit",
      type: "l11",
      exponent: 0,
      rw: "rw",
      default: 0x0258,
    },
    {
      address: 0x35,
      name: "VIN_ON",
      des: "The VIN_ON command sets the value of the input voltage, in volt, at which the PMBus unit should start power conversion",
      type: "l11",
      exponent: -1,
      rw: "rw",
      default: 0xF814,
    },
    {
      address: 0x36,
      name: "VIN_OFF",
      des: "The VIN_OFF command sets the value of the input voltage, in volt, at which the PMBus unit, once operation has started, should stop power conversion",
      type: "l11",
      exponent: -1,
      rw: "rw",
      default: 0xF812,
    },
    {
      address: 0x37,
      name: "INTERLEAVE",
      des: "The INTERLEAVE command is used to sets the mode of switching frequency and phase, at which the PMBus unit, once operation has started, should use to generate switching frequency and phase angle",
      type: "word",
      rw: "rw",
      default: 0x0100,
      parser: [
        {
          name: "Mode",
          pos: 0,
          len: 16,
          values: [
            {value: 0x0000, name: "STANDALONE", des: "The RT/SYNC pin shall not be used for other purposes"},
            {value: 0x0100, name: "MASTER", des: "After inside power VDD of the unit is above its under voltage level, the RT/SYNC pin will output a 50% duty cycle pulse signal in phase with the switching frequency, which may be used to drive other units set as the SLAVE mode by INTERLEAVE command"},
            {value: 0x0120, name: "SLAVE in phase", des: "When an external pulse switching signal is connected to the /SYNC pin, the unit will synchronize its switching frequency to the external pulse switching signal with 0º phase difference"},
            {value: 0x0121, name: "SLAVE out of phase", des: "When an external pulse switching signal is connected to the /SYNC pin, the unit will synchronize its switching frequency to the external pulse switching signal with 180º phase difference"},
          ],
        }
      ],
    },
    {
      address: 0x40,
      name: "VOUT_OV_FAULT_LIMIT",
      des: "The VOUT_OV_FAULT_LIMIT command sets the value of the output voltage measured at the sense of output pins that causes an output overvoltage fault",
      type: "l16",
      rw: "rw",
      default: 0x0161,
    },
    {
      address: 0x41,
      name: "VOUT_OV_FAULT_RESPONSE",
      des: "",
      type: "byte",
      rw: "rw",
      default: 0xF8,
      // values are from 10.5.1 of the PMBus 1.3 spec
      parser: [
        {
          name: "OVRSP",
          pos: 6,
          len: 2,
          values: [
            {value: 0b00, name: "continue", des: "The PMBus device continues operation without interruption"},
            {value: 0b11, name: "disabled while faulty", des: "The device's output is disabled while the fault is present. Operation resumes and the output is enabled when the fault condition no longer exists."},
          ],
        },
        {
          name: "OVRTY",
          pos: 3,
          len: 3,
          values: [
            {value: 0b000, name: "no restart", des: "Unit does not attempt to restart. The output remains disabled until the fault is cleared"},
            {value: 0b010, name: "retries 2", des: "2 attempts to restart"},
            {value: 0b100, name: "retries 4", des: "4 attempts to restart"},
            {value: 0b110, name: "retries 6", des: "6 attempts to restart"},
            {value: 0b111, name: "retries", des: "The device attempts to restart continuously"},
          ],
        },
        {
          name: "OVDLY",
          pos: 0,
          len: 3,
          values: [
            {value: 0b000, name: "no delay", des: "No delay"},
            {value: 0b010, name: "delay 2", des: "2 time units delay"},
            {value: 0b110, name: "delay 6", des: "6 time units delay"},
          ],
        }
      ],
    },
    {
      address: 0x42,
      name: "VOUT_OV_WARN_LIMIT",
      des: "The VOUT_OV_WARN_LIMIT command sets the value of the output voltage measured at the sense of output pins that causes an output voltage high warning",
      type: "l16",
      rw: "rw",
      default: 0x0151,
    },
    {
      address: 0x43,
      name: "VOUT_UV_WARN_LIMIT",
      des: "The VOUT_UV_WARN_LIMIT command sets the value of the output voltage measured at the sense of output pins that causes an output voltage low warning",
      type: "l16",
      rw: "rw",
      default: 0x0114,
    },
    {
      address: 0x44,
      name: "VOUT_UV_FAULT_LIMIT",
      des: "The VOUT_UV_FAULT_LIMIT command sets the value of the output voltage measured at the sense of output pins that causes an output undervoltage fault",
      type: "l16",
      rw: "rw",
      default: 0x00F5,
    },
    {
      address: 0x45,
      name: "VOUT_UV_FAULT_RESPONSE",
      des: "The VOUT_UV_FAULT_RESPONSE command instructs the device on what action to take in response to an output undervoltage fault",
      type: "byte",
      rw: "rw",
      default: 0xB9,
      // values are from 10.5.1 of the PMBus 1.3 spec
      parser: [
        {
          name: "UVRSP",
          pos: 6,
          len: 2,
          values: [
            {value: 0b00, name: "continue", des: "The device continues operation without interruption"},
            {value: 0b10, name: "retry", des: "The device shuts down (disables the output) and responds according to the UVRTY setting"},
            {value: 0b11, name: "disabled while faulty", des: "The device's output is disabled while the fault is present. Operation resumes and the output is enabled when the fault condition no longer exists."},
          ],
        },
        {
          name: "UVRTY",
          pos: 3,
          len: 3,
          values: [
            {value: 0b000, name: "no restart", des: "Unit does not attempt to restart. The output remains disabled until the fault is cleared"},
            {value: 0b010, name: "retries 1", des: "1 attempt to restart"},
            {value: 0b010, name: "retries 2", des: "2 attempts to restart"},
            {value: 0b110, name: "retries 6", des: "6 attempts to restart"},
            {value: 0b111, name: "retries", des: "The device attempts to restart continuously"},
          ],
        },
        {
          name: "UVDLY",
          pos: 0,
          len: 3,
          values: [
            {value: 0b000, name: "no delay", des: "No delay"},
            {value: 0b010, name: "delay 2", des: "2 time units delay"},
            {value: 0b110, name: "delay 6", des: "6 time units delay"},
          ],
        }
      ],
    },
    {
      address: 0x46,
      name: "IOUT_OC_FAULT_LIMIT",
      des: "The IOUT_OC_FAULT_LIMIT command sets the value of the output current, in Amperes, that causes the overcurrent detector to indicate an overcurrent fault condition.",
      type: "l11",
      exponent: -1,
      rw: "rw",
      default: 0xF82A,
    },
    {
      address: 0x47,
      name: "IOUT_OC_FAULT_RESPONSE",
      des: "The IOUT_OC_FAULT_RESPONSE is used to set device over current protection response (OCP) when valley inductor current is higher than IOUT_OC_FAULT_LIMIT",
      type: "byte",
      rw: "rw",
      default: 0xA1,
      // values are from 10.5.1 of the PMBus 1.3 spec
      parser: [
        {
          name: "OCRSP",
          pos: 6,
          len: 2,
          values: [
            {value: 0b00, name: "continue", des: "The device continues operation without interruption"},
            {value: 0b10, name: "retry", des: "The device shuts down (disables the output) and responds according to the UVRTY setting"},
            {value: 0b11, name: "disabled while faulty", des: "The device's output is disabled while the fault is present. Operation resumes and the output is enabled when the fault condition no longer exists."},
          ],
        },
        {
          name: "OCRTY",
          pos: 3,
          len: 3,
          values: [
            {value: 0b000, name: "no restart", des: "Unit does not attempt to restart. The output remains disabled until the fault is cleared"},
            {value: 0b010, name: "retries 2", des: "2 attempts to restart"},
            {value: 0b100, name: "retries 4", des: "4 attempts to restart"},
            {value: 0b110, name: "retries 6", des: "6 attempts to restart"},
            {value: 0b111, name: "retries", des: "The device attempts to restart continuously"},
          ],
        },
        {
          name: "OCDLY",
          pos: 0,
          len: 3,
          values: [
            {value: 0b000, name: "no delay", des: "No delay"},
            {value: 0b010, name: "delay 2", des: "2 time units delay"},
            {value: 0b110, name: "delay 6", des: "6 time units delay"},
          ],
        }
      ],
    },
    {
      address: 0x4A,
      name: "IOUT_OC_WARN_LIMIT",
      des: "The IOUT_OC_WARN_LIMIT command sets the value of the output current, in ampere, that causes an output overcurrent warning. This is a read and write register",
      type: "l11",
      exponent: -1,
      rw: "rw",
      default: 0xF827,
    },
    {
      address: 0x4F,
      name: "OT_FAULT_LIMIT",
      des: "The OT FAULT LIMIT command sets the temperature of the unit, in degree celsius, at which it should indicate an overtemperature fault. This is a read and write register",
      type: "l11",
      exponent: 0,
      rw: "rw",
      default: 0x007D,
    },
    {
      address: 0x50,
      name: "OT_FAULT_RESPONSE",
      des: "The OT_FAULT_RESPONSE command instructs the device on what action to take in response to an overtemperature fault",
      type: "byte",
      rw: "rw",
      default: 0xF9,
      // values are from 10.5.1 of the PMBus 1.3 spec
      parser: [
        {
          name: "OTRSP",
          pos: 6,
          len: 2,
          values: [
            {value: 0b00, name: "continue", des: "The device continues operation without interruption"},
            {value: 0b10, name: "retry", des: "The device shuts down (disables the output) and responds according to the retry setting"},
            {value: 0b11, name: "disabled while faulty", des: "The device's output is disabled while the fault is present. Operation resumes and the output is enabled when the fault condition no longer exists."},
          ],
        },
        {
          name: "OTRTY",
          pos: 3,
          len: 3,
          values: [
            {value: 0b000, name: "no restart", des: "Unit does not attempt to restart. The output remains disabled until the fault is cleared"},
            {value: 0b010, name: "retries 2", des: "2 attempts to restart"},
            {value: 0b100, name: "retries 4", des: "4 attempts to restart"},
            {value: 0b110, name: "retries 6", des: "6 attempts to restart"},
            {value: 0b111, name: "retries", des: "The device attempts to restart continuously"},
          ],
        },
        {
          name: "OTDLY",
          pos: 0,
          len: 3,
          values: [
            {value: 0b000, name: "no delay", des: "No delay"},
            {value: 0b001, name: "delay 1", des: "1 time unit delay"},
            {value: 0b010, name: "delay 2", des: "2 time units delay"},
            {value: 0b110, name: "delay 6", des: "6 time units delay"},
          ],
        }
      ],
    },
    {
      address: 0x51,
      name: "OT_WARN_LIMIT",
      des: "The OT_WARN_LIMIT command sets the temperature of the unit, in degree celsius, at which it should indicate an overtemperature warning alarm",
      type: "l11",
      exponent: 0,
      rw: "rw",
      default: 0x0069,
    },
    {
      address: 0x55,
      name: "VIN_OV_FAULT_LIMIT",
      des: "The VIN_OV_FAULT_LIMIT command sets the value of the input voltage, in volt, that causes an input overvoltage fault",
      type: "l11",
      exponent: -1,
      rw: "rw",
      default: 0xF81E,
    },
    {
      address: 0x56,
      name: "VIN_OV_FAULT_RESPONSE",
      des: "The VIN_OV_FAULT_RESPONSE command instructs the device on what action to take in response to an input overvoltage fault",
      type: "byte",
      rw: "rw",
      default: 0xB8,
      // values are from 10.5.1 of the PMBus 1.3 spec
      parser: [
        {
          name: "OVRSP",
          pos: 6,
          len: 2,
          values: [
            {value: 0b00, name: "continue", des: "The device continues operation without interruption"},
            {value: 0b11, name: "disabled while faulty", des: "The device's output is disabled while the fault is present. Operation resumes and the output is enabled when the fault condition no longer exists."},
          ],
        },
        {
          name: "OVRTY",
          pos: 3,
          len: 3,
          values: [
            {value: 0b000, name: "no restart", des: "Unit does not attempt to restart. The output remains disabled until the fault is cleared"},
            {value: 0b010, name: "retries 2", des: "2 attempts to restart"},
            {value: 0b100, name: "retries 4", des: "4 attempts to restart"},
            {value: 0b110, name: "retries 6", des: "6 attempts to restart"},
            {value: 0b111, name: "retries", des: "The device attempts to restart continuously"},
          ],
        },
        {
          name: "OVDLY",
          pos: 0,
          len: 3,
          values: [
            {value: 0b000, name: "no delay", des: "No delay"},
            {value: 0b010, name: "delay 2", des: "2 time units delay"},
            {value: 0b110, name: "delay 6", des: "6 time units delay"},
          ],
        }
      ],
    },
    {
      address: 0x58,
      name: "VIN_UV_WARN_LIMIT",
      des: "The VIN_UV_WARN_LIMIT command sets the value of the input voltage, in volt, that causes an input voltage low warning",
      type: "l11",
      exponent: -1,
      rw: "rw",
      default: 0xF812,
    },
    {
      address: 0x5D,
      name: "IIN_OC_WARN_LIMIT",
      des: "The IIN_OC_WARN_LIMIT command sets the value of the input current, in ampere, that causes an input current overcurrent Warning",
      type: "l11",
      exponent: -1,
      rw: "rw",
      default: 0xF80A,
    },
    {
      address: 0x5E,
      name: "POWER_GOOD_ON",
      des: "The POWER_GOOD_ON command sets the value of the output voltage at which an optional power good signal should be asserted, indicating that the output voltage is valid.",
      type: "l16",
      rw: "rw",
      default: 0x0114,
    },
    {
      address: 0x5F,
      name: "POWER_GOOD_OFF",
      des: "The POWER_GOOD_OFF command sets the value of the output voltage at which an optional power good signal should be negated, indicating that the output voltage is not valid.",
      type: "l16",
      rw: "rw",
      default: 0x0105,
    },
    {
      address: 0x60,
      name: "TON_DELAY",
      des: "The TON_DELAY command sets the time, in millisecond, from which a start condition is received (as programmed by the ON_OFF_CONFIG command) until the output voltage starts to rise",
      type: "l11",
      exponent: 0,
      rw: "rw",
      default: 0x0000,
    },
    {
      address: 0x61,
      name: "TON_RISE",
      des: "The TON_RISE command sets the time, in millisecond, from when the output starts to rise until the voltage has entered the regulation band",
      type: "l11",
      exponent: 0,
      rw: "rw",
      default: 0x0005,
    },
    {
      address: 0x62,
      name: "TON_MAX_FAULT_LIMIT",
      des: "The TON_MAX_FAULT_LIMIT command sets an upper limit, in millisecond, on how long the unit can attempt to power up the output without reaching the output undervoltage fault limit.",
      type: "l11",
      exponent: 0,
      rw: "rw",
      default: 0x0014,
    },
    {
      address: 0x63,
      name: "TON_MAX_FAULT_RESPONSE",
      des: "The TON_MAX_FAULT_RESPONSE command instructs the device on what action to take in response to an input overcurrent fault",
      type: "byte",
      rw: "rw",
      default: 0xB9,
      // values are from 10.5.1 of the PMBus 1.3 spec
      parser: [
        {
          name: "ONMXRSP",
          pos: 6,
          len: 2,
          values: [
            {value: 0b10, name: "retry", des: "The device shuts down (disables the output) and responds according to the retry setting"},
          ],
        },
        {
          name: "ONMXRTY",
          pos: 3,
          len: 3,
          values: [
            {value: 0b000, name: "no restart", des: "Unit does not attempt to restart. The output remains disabled until the fault is cleared"},
            {value: 0b001, name: "retries 1", des: "1 attempt to restart"},
            {value: 0b111, name: "retries", des: "The device attempts to restart continuously"},
          ],
        },
        {
          name: "ONMXDLY",
          pos: 0,
          len: 3,
          values: [
            {value: 0b000, name: "no delay", des: "No delay"},
            {value: 0b001, name: "delay 1", des: "1 time unit delay"},
            {value: 0b010, name: "delay 2", des: "2 time units delay"},
            {value: 0b011, name: "delay 3", des: "3 time units delay"},
            {value: 0b110, name: "delay 6", des: "6 time units delay"},
          ],
        }
      ],
    },
    {
      address: 0x64,
      name: "TOFF_DELAY",
      des: "The TOFF_DELAY command sets the time, in millisecond, from when a stop condition is received until the unit stops transferring energy to the output.",
      type: "l11",
      exponent: 0,
      rw: "rw",
      default: 0x0000,
    },
    {
      address: 0x65,
      name: "TOFF_FALL",
      des: "The TOFF_FALL command sets the time, in millisecond, from the end of the turn-off delay time until the voltage is commanded to zero. Note that this command can only be used with a device whose output can sink enough current to cause the output voltage to decrease at a controlled rate",
      type: "l11",
      exponent: 0,
      rw: "rw",
      default: 0x0005,
    },
    {
      address: 0x66,
      name: "TOFF_MAX_WARN_LIMIT",
      des: "The TOFF_MAX_WARN_LIMIT command sets an upper limit, in millisecond, on how long the unit can attempt to power down the output without reaching 12.5 % of the output voltage programmed at the time the unit is turned off.",
      type: "l11",
      exponent: 0,
      rw: "rw",
      default: 0x003C,
    },
    {
      address: 0x78,
      name: "STATUS_BYTE",
      des: "The STATUS_BYTE command returns one byte of information with a summary of the most critical faults. ",
      type: "byte",
      rw: "r",
      parser: [
        {
          name: "BUSY",
          pos: 7,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A fault was declared because the device was busy and unable to respond"},
          ],
        },
        {
          name: "OFF",
          pos: 6,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "This bit is asserted if the unit is not providing power to the output, regardless of the reason, including simply not being enabled"},
          ],
        },
        {
          name: "VOUT_OV_FAULT",
          pos: 5,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "An output overvoltage fault has occurred"},
          ],
        },
        {
          name: "IOUT_UV_FAULT",
          pos: 4,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "An output overcurrent fault has occurred"},
          ],
        },
        {
          name: "VIN_UV_FAULT",
          pos: 3,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "An input undervoltage fault has occurred"},
          ],
        },
        {
          name: "Temperature",
          pos: 2,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A temperature fault or warning has occurred"},
          ],
        },
        {
          name: "CML",
          pos: 1,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A communications, memory or logic fault has occurred"},
          ],
        },
        {
          name: "Other",
          pos: 0,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A fault or warning not listed in bits (7 to 1) has occurred"},
          ],
        },
      ],
    },
    {
      address: 0x79,
      name: "STATUS_WORD",
      des: "The STATUS_WORD command returns two bytes of information with a summary of the unit’s fault condition. Based on the information in these bytes, the host can get more information by reading the appropriate status registers.",
      type: "word",
      rw: "r",
      parser: [
        {
          name: "BUSY",
          pos: 15,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A fault was declared because the device was busy and unable to respond"},
          ],
        },
        {
          name: "OFF",
          pos: 14,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "This bit is asserted if the unit is not providing power to the output, regardless of the reason, including simply not being enabled"},
          ],
        },
        {
          name: "VOUT_OV_FAULT",
          pos: 13,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "An output overvoltage fault has occurred"},
          ],
        },
        {
          name: "IOUT_UV_FAULT",
          pos: 12,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "An output overcurrent fault has occurred"},
          ],
        },
        {
          name: "VIN_UV_FAULT",
          pos: 11,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "An input undervoltage fault has occurred"},
          ],
        },
        {
          name: "Temperature",
          pos: 10,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A temperature fault or warning has occurred"},
          ],
        },
        {
          name: "CML",
          pos: 9,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A communications, memory or logic fault has occurred"},
          ],
        },
        {
          name: "Other",
          pos: 8,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A fault or warning not listed in bits (7 to 1) has occurred"},
          ],
        },
        {
          name: "VOUT",
          pos: 7,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "An output voltage fault or warning has occurred"},
          ],
        },
        {
          name: "IOUT POUT",
          pos: 6,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "An output current or output power fault or warning has occurred"},
          ],
        },
        {
          name: "Input",
          pos: 5,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "An input voltage, input current, or input power fault or warning has occurred"},
          ],
        },
        {
          name: "MFR",
          pos: 4,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A manufacturer specific fault or warning has occurred"},
          ],
        },
        {
          name: "Power good",
          pos: 3,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "The power good signal, if present, is negated"},
          ],
        },
      ],
    },
    {
      address: 0x7A,
      name: "STATUS_VOUT",
      type: "byte",
      rw: "r",
      parser: [
        {
          name: "VOUT OV fault",
          pos: 7,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "VOUT OV fault (output overvoltage fault)"},
          ],
        },
        {
          name: "VOUT OV warning",
          pos: 6,
          len: 1,
          values: [
            {value: 0b0, name: "no warning"},
            {value: 0b1, name: "warning", des: "VOUT OV warning (output overvoltage warning)"},
          ],
        },
        {
          name: "VOUT UV warning",
          pos: 5,
          len: 1,
          values: [
            {value: 0b0, name: "no warning"},
            {value: 0b1, name: "warning", des: "VOUT UV warning (output undervoltage warning)"},
          ],
        },
        {
          name: "VOUT UV fault",
          pos: 4,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "VOUT UV fault (output undervoltage fault)"},
          ],
        },
        {
          name: "VOUT max min",
          pos: 3,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "V OUT max. min. (an attempt has been made to set the output voltage toa value higher than allowed by the V OUT max. or lower than the limited allowed by the VOUT min.)"},
          ],
        },
        {
          name: "tON max fault",
          pos: 2,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "tON max fault"},
          ],
        },
        {
          name: "tOFF max warning",
          pos: 1,
          len: 1,
          values: [
            {value: 0b0, name: "no warning"},
            {value: 0b1, name: "warning", des: "tOFF max warning"},
          ],
        },
      ],
    },
    {
      address: 0x7B,
      name: "STATUS_IOUT",
      type: "byte",
      rw: "r",
      parser: [
        {
          name: "IOUT OC fault",
          pos: 7,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "IOUT OC fault (output overcurrent fault)"},
          ],
        },
        {
          name: "IOUT OC warning",
          pos: 5,
          len: 1,
          values: [
            {value: 0b0, name: "no warning"},
            {value: 0b1, name: "warning", des: "IOUT OC warning (output overcurrent warning)"},
          ],
        },
      ],
    },
    {
      address: 0x7C,
      name: "STATUS_INPUT",
      type: "byte",
      rw: "r",
      parser: [
        {
          name: "VIN OV fault",
          pos: 7,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "VIN OV fault (input overvoltage fault)"},
          ],
        },
        {
          name: "VIN UV warning",
          pos: 5,
          len: 1,
          values: [
            {value: 0b0, name: "no warning"},
            {value: 0b1, name: "warning", des: "VIN UV warning (input undervoltage warning)"},
          ],
        },
        {
          name: "VIN off",
          pos: 3,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "Unit off for insufficient input voltage"},
          ],
        },
        {
          name: "IIN OC warning",
          pos: 1,
          len: 1,
          values: [
            {value: 0b0, name: "no warning"},
            {value: 0b1, name: "warning", des: "IIN OC warning (input overcurrent warning)"},
          ],
        },
      ],
    },
    {
      address: 0x7D,
      name: "STATUS_TEMPERATURE",
      type: "byte",
      rw: "r",
      parser: [
        {
          name: "OT fault",
          pos: 7,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "OT fault (overtemperature fault)"},
          ],
        },
        {
          name: "OT warning",
          pos: 6,
          len: 1,
          values: [
            {value: 0b0, name: "no warning"},
            {value: 0b1, name: "warning", des: "OT warning (overtemperature warning)"},
          ],
        },
      ],
    },
    {
      address: 0x7E,
      name: "STATUS_CML",
      type: "byte",
      rw: "r",
      parser: [
        {
          name: "Invalid command",
          pos: 7,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "Invalid or unsupported command received"},
          ],
        },
        {
          name: "Invalid data",
          pos: 6,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "Invalid or unsupported data received"},
          ],
        },
        {
          name: "PEC failed",
          pos: 5,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "Packet error check failed"},
          ],
        },
        {
          name: "Memory fault",
          pos: 4,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "Memory fault detected"},
          ],
        },
        {
          name: "Other",
          pos: 1,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "A communication fault other than the ones listed in this table has occurred"},
          ],
        },
      ],
    },
    {
      address: 0x80,
      name: "STATUS_MFR_SPECIFIC",
      type: "byte",
      rw: "r",
      parser: [
        {
          name: "IL master",
          pos: 3,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "IL master fault"},
          ],
        },
        {
          name: "YF verify",
          pos: 2,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "YF verify fault"},
          ],
        },
        {
          name: "YF erase",
          pos: 1,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "YF erase fault"},
          ],
        },
        {
          name: "YF PGM",
          pos: 0,
          len: 1,
          values: [
            {value: 0b0, name: "no fault"},
            {value: 0b1, name: "fault", des: "YF PGM fault"},
          ],
        },
      ],
    },
    {
      address: 0x88,
      name: "READ_VIN",
      des: "The READ_VIN command returns the input voltage in volt.",
      type: "l11",
      rw: "r",
    },
    {
      address: 0x89,
      name: "READ_IIN",
      des: "The READ_IIN command returns the input current in ampere",
      type: "l11",
      rw: "r",
    },
    {
      address: 0x8B,
      name: "READ_VOUT",
      des: "The read VOUT command returns the actual, measured output voltage in volt.",
      type: "l16",
      rw: "r",
    },
    {
      address: 0x8C,
      name: "READ_IOUT",
      des: "The READ_IOUT command returns the measured output current in ampere.",
      type: "l11",
      rw: "r",
    },
    {
      address: 0x8D,
      name: "READ_TEMPERATURE",
      des: "The READ_TEMPERATURE command returns the measured temperature of the PMBus unit in degree celsius.",
      type: "l11",
      rw: "r",
    },
    {
      address: 0x94,
      name: "READ_DUTY_CYCLE",
      des: "The READ_DUTY_CYCLE command returns the duty of the PMBus unit’s power conversion in percent.",
      type: "l11",
      rw: "r",
    },
    {
      address: 0x96,
      name: "READ_POUT",
      des: "The READ_POUT command returns the output power, in watt, of the PMBus unit.",
      type: "l11",
      rw: "r",
    },
    {
      address: 0x97,
      name: "READ_PIN",
      des: "The READ_PIN command returns the input power, in watt, of the PMBus unit.",
      type: "l11",
      rw: "r",
    },
    {
      address: 0x98,
      name: "PMBUS_REVISION",
      des: "The PMBUS_REVISION command stores or reads the revision of the PMBus to which the device is compliant.",
      type: "byte",
      rw: "r",
      default: 0x33,
      parser: [
        {
          name: "Part 1",
          pos: 4,
          len: 4,
          values: [
            {value: 0b0000, name: "revision 1.0"},
            {value: 0b0001, name: "revision 1.1"},
            {value: 0b0010, name: "revision 1.2"},
            {value: 0b0011, name: "revision 1.3"},
          ],
        },
        {
          name: "Part 2",
          pos: 0,
          len: 4,
          values: [
            {value: 0b0000, name: "revision 1.0"},
            {value: 0b0001, name: "revision 1.1"},
            {value: 0b0010, name: "revision 1.2"},
            {value: 0b0011, name: "revision 1.3"},
          ],
        },
      ],
    },
    {
      address: 0x9E,
      name: "MFR_SERIAL",
      des: "The MFR_SERIAL command is used to store user’s customized information.",
      type: "word",
      rw: "rw",
    },
    {
      address: 0xAD,
      name: "IC_DEVICE_ID",
      des: "The IC_DEVICE_ID command is used to either set or read the type or part number of an IC embedded within a PMBus that is used for the PMBus interface. Each manufacturer uses the format of their choice for the IC device identification. IC_DEVICE_ID is typically only set once, at the time of manufacture.",
      type: "word",
      rw: "rw",
      default: 0x0000,
    },
    {
      address: 0xD7,
      name: "MFR_BASE_ADDRESS",
      des: "",
      type: "byte",
      rw: "rw",
      default: 0x10,
      visible: false,
    },
    {
      address: 0xE2,
      name: "MFR_BASE_ADDRESS_2",
      des: "",
      type: "byte",
      rw: "rw",
      default: 0x50,
      visible: false,
    },
  ],
  customMacros: "// Scale loop constants for VOUT ranges\n#define SIC45X_VOUT_SCALE_LOOP_0V3_1V8 1.0\n#define SIC45X_VOUT_SCALE_LOOP_1V8_3V3 0.5\n#define SIC45X_VOUT_SCALE_LOOP_3V3_5V0 0.25\n#define SIC45X_VOUT_SCALE_LOOP_5V0_12V0 0.125"
};

main(pmbusConfig);